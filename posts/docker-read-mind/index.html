<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>第一本Docker书 笔记</title>
		<meta name="viewport" content="width=device-width">
		
		<link rel="stylesheet" href="https://example.comcss/hybrid.css">
		<link rel="stylesheet" href="https://example.comcss/style.css">
		<link rel="stylesheet" href="https://example.comcss/colors-dark.css">

		
	</head>
	<body>
		<header id="header">
			<h1><a href="https://example.com">life</a></h1>
			<p>Hugo theme zozo example site.</p>
		</header>

		<div id="page">
			<div id="sidebar">
				<nav>
	
		<ul class="nav">
			
				<li><a href="/"><span>首页</span></a></li>
			
				<li><a href="/posts/"><span>归档</span></a></li>
			
				<li><a href="/tags/"><span>标签</span></a></li>
			
				<li><a href="/about/"><span>关于</span></a></li>
			
		</ul>
	
</nav>

			</div>

			<div id="content">
				
	<article class="post">
		<h1><a href="https://example.com/posts/docker-read-mind/">第一本Docker书 笔记</a> </h1>

		<div class="post-content">

<h1 id="第一本docker书">第一本Docker书</h1>

<h2 id="第一章-简介">第一章 简介</h2>

<h4 id="1-1-1-提供一个简单轻量的建模方式">1.1.1 提供一个简单轻量的建模方式</h4>

<ul>
<li><p>docker及其简洁，全部环境一台安装了肩同版本的Linux内核和二进制文件最小限的宿主机</p></li>

<li><p>大多数docker容器只需要不到1秒钟即可启动</p></li>

<li><p>由于去除了管理程序的开销，docker容器拥有很高大的性能，充分的利用资源</p></li>
</ul>

<h4 id="1-1-2-职责的逻辑分离">1.1.2 职责的逻辑分离</h4>

<ul>
<li>使用docker

<ul>
<li>开发人员只需要关心容器中运行的程序</li>
<li>运维人员只需要关心如何管理容器</li>
</ul></li>
<li>docker设计目的就是要加强开发人员写代码的开发环境与应用程序要部署环境的一致性</li>
</ul>

<h4 id="1-1-3-快速高效的开发生命周期">1.1.3 快速高效的开发生命周期</h4>

<h4 id="1-1-3-鼓励使用面向服务的架构">1.1.3 鼓励使用面向服务的架构</h4>

<ul>
<li>docker鼓励面向服务的架构和微服务架构</li>
<li>推荐一个容器只运行一个应用程序或进程，形成一个分布式的应用模型，分布式的部署应用，扩展或调试应用变得简单，提高程序的内省性（什么意思？）</li>
</ul>

<h3 id="1-2docker组件">1.2docker组件</h3>

<ul>
<li>客户端和服务器：c/s架构，命令行工具docker与一整套RESTful API</li>
<li>镜像：镜像是基于联合（Union）文件系统的一种层级结构</li>
<li>Registry： 类似于github</li>
<li>容器：

<ul>
<li>容器是基于镜像启动起来的，容器中可以运行一个或多个进程</li>
<li>可以认为，竟像是docker生命周期中的侯建或打包阶段，容器是启动或执行阶段。</li>
<li>总结，docker容器：</li>
<li>一个镜像格式</li>
<li>一系列标准操作</li>
<li>一个执行环境</li>
</ul></li>
</ul>

<h3 id="1-3-我们能用docker做什么">1.3 我们能用docker做什么</h3>

<ul>
<li>加快本地开发和构建流程，高效，轻量化</li>
<li>独立的服务或应用在不同的环境中，得到相同的结果</li>
<li>创建隔离环境来进行测试，如Jenkins CI 启动一个测试容器</li>
<li>构建一个多用户的平台即服务（PaaS）基础设施（什么意思？）</li>
<li>提供软件即服务（SaaS）应用程序</li>
<li>高性能，超大规模的宿主机部署</li>
</ul>

<h3 id="1-4docker与配置管理">1.4docker与配置管理</h3>

<h3 id="1-5-docker的技术组件">1.5 docker的技术组件</h3>

<ul>
<li>Linux内核的x64主机上</li>
<li>内核版本 &gt;=3.8</li>
<li>Linux内核的命名空间（namespace）：

<ul>
<li>文件系统隔离： 每个容器都有自己的root文件系统</li>
<li>进程隔离： 每个容器都隐形在自己的进程环境中</li>
<li>网络隔离： 容器间的虚拟网络接口和IP地址都是分开的</li>
<li>资源隔离和分组： 使用cgroups（即control group，Linux 的内核特性之一）将CPU和内存之类的资源独立分配给每个Docker容器</li>
<li>写时复制： 文件系统都是通过写时复制常见的，意味着文件系统时分层的，快速的，占用磁盘空间更小（什么意思？）</li>
<li>日志： 容器的stdout，stderr，stdin这些IO流都会被收集并计入日志，用来进行日志分析和故障排错。</li>
<li>交互式shell： 可以创建一个伪tty终端， 将其连接到STDIN，为容器提供一个交互式shell。</li>
</ul></li>
</ul>

<h2 id="第二章-安装docker">第二章 安装docker</h2>

<h3 id="2-1-安装docker的先决条件">2.1 安装docker的先决条件</h3>

<ul>
<li>运行64位CPU架构的计算机（x86_64和amd64），不支持32位CPU</li>
<li>Linux 内核 &gt;= 3.8</li>
<li>内核必须支持一种适合的存储驱动（storage driver）（默认粗出驱动通常是Device Mapper）</li>
<li>讷河必须支持并开启cgroup和命名空间（namespace）功能。</li>
</ul>

<h3 id="2-2-ubuntu中安装docker">2.2 Ubuntu中安装docker</h3>

<h4 id="2-2-1-检查前提条件">2.2.1 检查前提条件</h4>

<ul>
<li>检查内核：

<ul>
<li>uname -a</li>
</ul></li>
<li>检查 Device Mapper：

<ul>
<li>ls -l /sys/class/misc/device-mapper（自2.6.9版本的Linux 内核开始已经集成Device Mapper）</li>
<li>grep device-mapper /proc/devices</li>
</ul></li>
<li>cgroup和命名空间自2.6版本开始已经集成在Linux内核中了。2.6.38 以后的内核对cgroup和命名空间都义工了良好的支持，基本上没有bug</li>
</ul>

<h2 id="第三章-docker入门">第三章 docker入门</h2>

<ul>
<li>查询docker信息

<ul>
<li>docker info</li>
</ul></li>
<li>运行容器

<ul>
<li>docker run -i -t ubuntu /bin/bash</li>
<li>-i 保证容器中的stdin是开启的</li>
<li>-t 告诉docker分配一个伪tty终端</li>
<li>ubuntu 告诉docker 用什么镜像来创建容器</li>
<li>/bin/bash 在启动镜像后运行的命令</li>
</ul></li>
<li>容器的命名

<ul>
<li>docker run —name my_container1.2.3 -i -t ubuntu /bin/bash</li>
<li>—name 可以指定容器的名字 只能使用[a-zA-Z0-9_.-]（正则）</li>
</ul></li>
<li>容器的启动。停止与重启

<ul>
<li>docker run my_container</li>
<li>docker stop ...</li>
<li>docker restart ...</li>
</ul></li>
</ul>

<h3 id="3-6-附着到容器上">3.6 附着到容器上</h3>

<ul>
<li>docker容器重新启动的时候，会沿用docker run 命令时指定的参数来运行，我们可以用docker attach 命令重新附着到该容器的会话上，输入命令后可能需要按下回车</li>
</ul>

<h3 id="3-7-创建守护式容器">3.7 创建守护式容器</h3>

<p>除了交互式容器，还可以创建长期运行的容器（守护式容器 daemonized container）没有交互式会话，非常适合运行应用程序和服务</p>

<ul>
<li>docker run —name daemon -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;

<ul>
<li>-d 会将容器放到后台运行</li>
</ul></li>
</ul>

<h3 id="3-8-docker-日志">3.8 docker 日志</h3>

<ul>
<li>docker logs container_name 可以查看容器的日志输出</li>
<li>docker logs -f container_name 可以像tail -f 那样看实时输出</li>
<li>docker logs —tail 0 -f container_name  可以从查看当前命令后的实时输出</li>
<li>docker logs —tail 10 container_name 可以获取日志最后的10条日志</li>
</ul>

<h3 id="3-9-容器内进程查看">3.9 容器内进程查看</h3>

<ul>
<li>docker ps container_name</li>
</ul>

<h3 id="3-10-在容器内部运行进程">3.10 在容器内部运行进程</h3>

<ul>
<li>docker 1.3之后，可以使用docker exec 命令在容器内部额外启动新进程，在容器中运行的进程有两种类型

<ul>
<li>交互式进程： 保持在前台运行</li>
<li>后台任务</li>
</ul></li>
<li>创建后台任务

<ul>
<li>docker exec -d c1 touch /etc/new_config_file</li>
<li>-d 表明需要运行一个后台进程</li>
<li>-d 之后，指定容器的名字，执行的命令</li>
</ul></li>
<li>创建交互式进程

<ul>
<li>docker exec -i -t c1 /bin/bash</li>
<li>-t，-i创建TTY并捕捉STDIN</li>
<li>随后是容器名， 以及执行的敏玲</li>
</ul></li>
</ul>

<h3 id="3-12-自动重启容器">3.12 自动重启容器</h3>

<ul>
<li>可以通过设置—restart标志来设置重启

<ul>
<li>docker run —restart=always —name c1 -d ubuntu /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</li>
<li>—restart=always无论退出代码是什么都会重启容器</li>
<li>—restart=on-failure:5只有当退出代码为非0值时才能重启，并且可以添加参数，重启数量如5</li>
</ul></li>
</ul>

<h3 id="3-13-深入容器">3.13 深入容器</h3>

<ul>
<li>docker inspect —formate='{{ .State.Running}}'可以获取更多的容器信息

<ul>
<li>—formate 或 -f 可以获取制定的信息</li>
<li><em>可以同时制定多个容器</em></li>
<li>f 没有表面这么简单，他可以支持完整的Go语言模板</li>
</ul></li>
<li>可以浏览/var/lib/docker目录来深入了解docker的工作原理

<ul>
<li>该目录下存放docker镜像、容器以及容器的配置</li>
</ul></li>
</ul>

<h3 id="3-14-删除容器">3.14 删除容器</h3>

<ul>
<li>运行中的docker容器是无法删除的，只能先docker stop 或 docker kill来停止容器</li>
<li>目前没有办法一次性删除所有容器，不过可以

<ul>
<li>docker rm 'docker ps -a -q'</li>
<li>-a 显示所有容器 -q 表示只需要返回 容器ID</li>
</ul></li>
</ul>

<h2 id="第四章-使用docker镜像和仓库">第四章 使用docker镜像和仓库</h2>

<p><em>关于镜像的知识，镜像的管理、修改、创建、存储、共享、镜像仓库</em></p>

<h3 id="4-1-什么是docker镜像">4.1 什么是docker镜像</h3>

<p><em>docker镜像是由文件系统叠加而成</em></p>

<ul>
<li>最低端是一个引导文件系统，即bootfs，这很像典型的Linux/Unix 的引导文件系统。当容器启动，它将会被移到内存中，引导文件系统则会被卸载，以留出更多的内存供initrd磁盘镜像使用</li>
<li>第二层是root文件系统rootfs，rootfs可以是一种或多种操作系统（什么意思？），在docker中root文件系统永远只能是只读状态，并且使用联合加载技术，联合加载技术会将各层文件系统叠加到一起，这样文件系统就包含所有底层的文件和目录。</li>
<li><em>写实复制：</em>

<ul>
<li>当docker第一次启动一个容器时，初始的读写层是空的。当文件系统发生变化时，这些变化都会应用到这一层上。比如，如果想修改一个文件，这个文件首先会从该读写层下面的只读层复制到该读写层。该文件的只读版本依然存在，但是已经被读写层中的该文件副本所隐藏</li>
<li>每个只读镜像层都是只读的，并且以后永远不会变化</li>
<li>当创建一个新容器时，docker会构建出一个镜像栈，并在栈的最顶端添加一个读写层。这个读写层再加上其下面的镜像层以及一些配置数据，就构成了一个容器</li>
<li>容器的这种特点加上镜像分层框架（image-layering-framework），使我们可以快速构建镜像并运行</li>
</ul></li>
</ul>

<h3 id="4-3-镜像拉取-查找">4.3 镜像拉取、查找</h3>

<ul>
<li>docker pull image_name:tag  如果不指定tag 则默认下载latest</li>
<li>docker search image_name</li>
</ul>

<h3 id="4-5-构建镜像">4.5 构建镜像</h3>

<ul>
<li>docker commit （不推荐）</li>
<li>docker build 和Dockerfile文件</li>
</ul>

<h4 id="4-5-3-用dockerfile-构建镜像">4.5.3 用Dockerfile 构建镜像</h4>

<ul>
<li>基于DSL语法的指令来构建一个Docker 镜像，</li>
</ul>

<h4 id="4-5-10-dockerfile指令">4.5.10 Dockerfile指令</h4>

<ul>
<li>CMD：

<ul>
<li>指定容器要运行时执行的命令</li>
<li>如果在docker run 时添加了执行命令，该字段失效</li>
</ul></li>
<li>ENTRYPOINT

<ul>
<li>类似于CMD</li>
<li>可以接受docker run传入的参数（docker run -t -i docker/study:v1 -g &quot;daemon off;&quot;）</li>
<li>ENTRYPOINT 可以和CMD公用</li>
<li>ENTRYPOINT [&quot;/usr/sbin/nginx&quot;]; CMD [&quot;-h&quot;]</li>
<li>可以使用 --entrypoint标志覆盖该命令</li>
</ul></li>
<li>WORKDIR

<ul>
<li>WORKDIR /opt/webapp/db</li>
<li>指定改字段的值后，会使ENTRYPOINT与CMD在指定目录执行</li>
<li>可以为容器设置最终工作目录</li>
<li>可以设置多次</li>
<li>可以通过-w参数覆盖最终工作目录的设置</li>
</ul></li>
<li>ENV

<ul>
<li>ENV RVM_PATH /home/rvm/</li>
<li>WORKDIR $RVM_PATH</li>
<li>在镜像构建过程总设置环境变量</li>
<li>可以通过环境变量前加上一个反斜杠进行转义</li>
<li>可以通过启动容器是-e 指定，该指定只会作用于运行时</li>
</ul></li>
<li>USER

<ul>
<li>用来指定镜像会以什么样的用户去运行</li>
<li>启动容器时增加-u 可以覆盖该值</li>
<li>如果不指定默认是root用户</li>
</ul></li>
<li>VOLUME

<ul>
<li>VOLUME [&quot;/opt/project&quot;, &quot;/data&quot;] 可以逗号分隔指定多个卷</li>
<li>卷可以将内容添加到镜像中，而不是将这些内容提交到镜像中</li>
</ul></li>
<li>ADD

<ul>
<li>ADD software.lic /opt/application/software.lic</li>
<li>将构建环境下的文件和目录复制到镜像中</li>
<li>指向源文件的位置参数可以是一个URL，或者侯建上下文或环境中文件名或者目录</li>
<li><em>不能对构建目录或者上下文之外的文件进行ADD操作</em></li>
<li>会根据路径的最后一个字符是否是“/”来判断是目录或者文件</li>
<li>如果将一个归档文件（gzip、bzip2、xz）指定为源文件，docker会自动将归档文件解开（unpack） ADD latest.tar.gz /var/www/wordpress/，解开行为和-x选项的tar命令一样</li>
<li>如果URL方式指定源是归档文件，是不能解开的</li>
<li>在归档情况下，如果目的目录中有与归档文件解开的文件或目录，那么位置中的文件或目录不会覆盖</li>
<li>如果目的目录不存在，则创建这个全路径，新创建的文件和目录的模式为0755， 并且UID和GID都是0</li>
<li>ADD命令会使构建缓存变得无效，会使后续指令都不能继续使用之前的侯建缓存</li>
</ul></li>
<li>COPY

<ul>
<li>COPY conf.d/ /etc/apache2/</li>
<li>和ADD很像，不会做提取工作</li>
<li>和ADD一样 源以&quot;/&quot;结尾，会将目录复制过去，否则当做文件</li>
</ul></li>
<li>ONBUILD

<ul>
<li>为镜像添加触发器，当一个镜像被用作其他镜像的基础镜像时，该镜像的触发器被执行。</li>
<li>触发器会在构建过程中插入新指令，可以认为这些指令紧跟FROM之后指定的</li>
<li>触发器可以是任何构建指令（除了FROM，MAINTAINER，ONBUILD）</li>
<li>ONBUILD ADD . /app/src</li>
<li>ONBUILD RUN cd /app/src &amp;&amp; make</li>
<li>ONBUILD指令可以通过docker inspect 命令来查看</li>
</ul></li>
</ul>

<h3 id="4-8-运行自己的docker-registry">4.8 运行自己的Docker registry</h3>

<ul>
<li>docker run -p 5000:5000 registry</li>
<li>需要将想上传到自己registry的镜像打包

<ul>
<li>docker tag imageID  host:port/{user}/static_web</li>
<li>docker push host:port/{user}/static_web</li>
<li>并且可以运行 docker run -t -i host:port/{user}/static_web /bin/bash</li>
</ul></li>
</ul>

<h2 id="第五章-在测试中使用docker">第五章 在测试中使用docker</h2>

<ul>
<li><em>使用docker测试一个静态网站</em></li>
<li><em>使用docker创建并测试一个web应用</em></li>
<li><em>将docker用于持续集成</em></li>
</ul>

<h3 id="5-1-使用docker测试静态网站">5.1 使用Docker测试静态网站</h3>

<ul>
<li>docker run -d -p 80 --name website -v $PWD/website:/var/www/html/website:{ro(只读)/rw(读写)}  d/s1 nginx</li>
<li>如果构建中出现任何问题，进入到容器中排查，不要修改=&gt;构建这样重复</li>
<li>静态文件的修改，可以直接修改宿主机的文件</li>
</ul>

<h3 id="5-2-使用docker构建并测试web应用">5.2 使用Docker构建并测试web应用</h3>

<ul>
<li>docker run -p 1338 --name webapp --link redis:db -t -i -v $PWD/webapp:/opt/webapp image /bin/bash</li>
<li>--link 创建了两个容器之间的父子链接</li>
<li>可以增加 --ioc=false标志，关闭所有没有连接的容器间的通信。</li>
<li>--linx 在docker 父容器中两个地方写入了链接信息

<ul>
<li>/etc/hosts 文件中</li>
<li>包含链接信息的环境变量中，可以同过env查看</li>
</ul></li>
</ul>

<h3 id="5-3-docker用于持续集成">5.3 Docker用于持续集成</h3>

<p><em>在docker镜像中运行docker，very interesting</em></p>

<ul>
<li><p>docker run -p 8080:8080 —name jenkins —privileged -d dockerjenkins</p></li>

<li><p>加—privileged 参数可以启动docker的特权模式，这种模式允许我们以其宿主机具有的所有能力来运行容器，包括一些内核特性和设备访问。</p></li>
</ul>

<h1 id="镜像加速monitor-https-ieevee-com-tech-2016-09-28-docker-mirror-html"><a href="https://ieevee.com/tech/2016/09/28/docker-mirror.html">镜像加速monitor</a></h1>

<h1 id="docker-100问-https-blog-lab99-org-post-docker-2016-07-14-faq-html"><a href="https://blog.lab99.org/post/docker-2016-07-14-faq.html">docker 100问</a></h1>

<h1 id="备注">备注</h1>

<p>什么意思？ ： 代表问题，需要了解</p>
</div>

		<p class="meta">Posted on <span class="postdate">12. September 2017</span></p>
	</article>

			</div>

			<footer id="footer">
				<p class="copyright">
					
						Powered by <a href="https://gohugo.io/">Hugo</a> and the
						<a href="https://github.com/bake/solar-theme-hugo">Solar</a>-theme.
					
				</p>
			</footer>
		</div>

		
	</body>
</html>
